<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="rest.templating">
    <title>Templating support</title>

    <para>
        Seam REST allows to create HTTP responses based on the defined templates. Instead of being bound
        to a particular
        templating engine, Seam REST comes with a support for multiple templating engines
        and support for others can be plugged
        in. 
	</para>

    <sect1>
        <sect1info>
        <title>Creating JAX-RS responses using templates</title>
        </sect1info>

        <para>
            REST-based web services are often expected to return multiple representations of a resource. The templating
            support is useful for producing media formats such as XHTML and it can be also used instead of JAXB to produce
            domain-specific XML representations of a resource. Besides, almost any other representation of a resource can be
            described
            in a template.			
		</para>

        <para>
            To enable templating for a particular method, decorate the method with the
            <literal>@ResponseTemplate</literal>
            annotation. Path to a template file to be used for rendering is required.
        </para>

        <example>
            <title>
                <literal>@ResponseTemplate</literal>
                in action
            </title>
            <programlisting role="JAVA"><![CDATA[@ResponseTemplate("/freemarker/task.ftl")
public Task getTask(@PathParam("taskId") long taskId) {
...
}]]></programlisting>
        </example>

        <para>
            The
            <literal>@ResponseTemplate</literal>
            annotation offers several other options. For example, it is possible for a method
            to offer multiple representations
            of a resource, each rendered with a different template.
            In the example below, the
            <literal>produces</literal>
            member of the
            <literal>@ResponseTemplate</literal>
            annotation is used
            to distinguish between produced media types.
        </para>

        <example>
            <title>
                Multiple
                <literal>@ResponseTemplate</literal>
                s
            </title>
            <programlisting role="JAVA"><![CDATA[@GET
@Produces( { "application/json", "application/categories+xml", "application/categories-short+xml" })
@ResponseTemplate.List({
      @ResponseTemplate(value = "/freemarker/categories.ftl", produces = "application/categories+xml"),
      @ResponseTemplate(value = "/freemarker/categories-short.ftl", produces = "application/categories-short+xml")
})
public List<Category> getCategories()]]></programlisting>
        </example>

        <table>
            <title>
                <literal>@ResponseTemplate</literal>
                options
            </title>
            <tgroup cols='4'>
                <thead>
                    <row>
                        <entry>Name</entry>
                        <entry>Required</entry>
                        <entry>Default value</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>value</literal>
                        </entry>
                        <entry>true</entry>
                        <entry>-</entry>
                        <entry>
                            Path to the template (for example
                            <literal>/freemarker/categories.ftl</literal>
                            )
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>produces</literal>
                        </entry>
                        <entry>false</entry>
                        <entry>*/*</entry>
                        <entry>Restriction of media type produced by the template
                            (useful in situations when a method produces
                            multiple media types,
                            with different templates)</entry>
                    </row>
                    <row>
                        <entry>
                            <literal>responseName</literal>
                        </entry>
                        <entry>false</entry>
                        <entry>response</entry>
                        <entry>Name under which the object returned by the JAX-RS method
                            is available in the template (for
                            example, Hello ${response.name})
						</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <sect2>
            <title>Accessing the model</title>

            <para>
                There are several ways of accessing the domain data within a template.
			</para>

            <para>
                Firstly, the object returned by the JAX-RS method is available under the "response" name by default.
                The object
                can be made available under a different name using the
                <literal>responseName</literal>
                member of the
                <literal>@ResponseTemplate</literal>
                annotation.
            </para>

            <example>
                <title>hello.ftl</title>
                <programlisting><![CDATA[Hello ${response.name}]]></programlisting>
            </example>

            <para>
                Secondly, every bean reachable via an EL expression is available within a template.
			</para>

            <example>
                <title>Using EL names in a template</title>
                <programlisting role="XML"><![CDATA[#foreach(${student} in ${university.students})
	<student>${student.name}</student>
#end]]></programlisting>
            </example>

            <note>
                <para>
                    Note that the syntax of the expression depends on the particular
                    templating engine and mostly differs from
                    the syntax of EL expressions. For example,
                    <literal>${university.students}</literal>
                    must be used instead of
                    <literal>#{university.students}</literal>
                    in a FreeMarker template.
                </para>
            </note>

            <para>
                Last but not least, the model can be populated programmatically. In order to do that, inject the
                <literal>TemplatingModel</literal>
                bean and put the desired objects into the underlying
                <literal>data</literal>
                map. In the following example, the list of professors is available under the "professors" name.
            </para>

            <example>
                <title>Defining model programmatically</title>
                <programlisting role="JAVA"><![CDATA[@Inject
private TemplatingModel model;
   
@GET
@ResponseTemplate("/freemarker/university.ftl")
public University getUniversity()
{
   // load university and professors
   University university = ...
   List<Professor> professors = ...
   
   model.getData().put("professors", professors);
   return university;
}]]></programlisting>
            </example>

        </sect2>

        <tip>
            <para>
                When using JAXB-annotated classes as a return type for JAX-RS methods, you may see the
                following RESTEasy message:
                <quote>Could not find JAXBContextFinder for media type: text/html</quote>
                . This is caused by the built-in JAXB
                provider being too eager. You can prevent the built-in JAXB provider from being used for a method by adding the
                <literal>@DoNotUseJAXBProvider</literal>
                annotation on the method.
            </para>
        </tip>

    </sect1>

    <sect1>
        <title>Built-in support for templating engines</title>

        <para>
            Seam REST currently comes with built-in templating providers for
            FreeMarker and Apache Velocity.
		</para>

        <sect2 id="rest.templating.freemarker">
            <title>FreeMarker</title>
            <para>
                FreeMarker is one of the most popular templating engines. To
                enable Seam REST FreeMarker support, bundle the
                FreeMarker jar with
                the web application.
			</para>

            <para>
                For more information on writing FreeMarker templates, refer to the
                <ulink url="http://freemarker.sourceforge.net/docs/index.html">FreeMarker Manual</ulink>
                .
            </para>
        </sect2>

        <sect2 id="rest.templating.velocity">
            <title>Apache Velocity</title>
            <para>
                Apache Velocity is another popular Java-based templating engine. Similarly to FreeMarker support,
                Velocity
                support is enabled automatically if Velocity libraries are detected on the classpath. 
			</para>

            <para>
                For more information on writing Velocity templates, refer to the
                <ulink url="http://velocity.apache.org/engine/releases/velocity-1.5/user-guide.html">Apache Velocity User Guide</ulink>
            </para>
        </sect2>

        <sect2>
            <title>Pluggable support for templating engines</title>
            <para>
                All that needs to be done to extend the set of supported templating engines is to implement
                the
                <literal>TemplatingProvider</literal>
                interface. Refer to
                <ulink url="http://docs.jboss.org/seam/3/rest/latest/api/org/jboss/seam/rest/templating/TemplatingProvider.html">Javadoc</ulink>
                for hints.
            </para>
        </sect2>

        <sect2>
            <title>Selecting preferred templating engine</title>
            <para>
                In certain deployment scenarios it is not possible to control
                the classpath completely and multiple template
                engines may be
                available at the same time. If that happens, Seam REST fails to
                operate with the following message:
            </para>

            <informalexample>
                <programlisting>Multiple TemplatingProviders found on classpath. Select the preferred one.</programlisting>
            </informalexample>

            <para>
                In such case, define the preferred templating engine in the XML
                configuration as demonstrated below to resolve
                the <literal>TemplatingProvider</literal> ambiguity.
			</para>

            <example>
                <title>Preferred provider</title>
                <programlisting role="XML"><![CDATA[<beans xmlns:rest="urn:java:org.jboss.seam.rest:org.jboss.seam.rest.exceptions">
	<rest:SeamRestConfiguration preferedTemplatingProvider="org.jboss.seam.rest.templating.freemarker.FreeMarkerProvider">
</beans>]]></programlisting>
            </example>

            <table>
                <title>Built-in templating providers</title>
                <tgroup cols='2'>
                    <thead>
                        <row>
                            <entry>Name</entry>
                            <entry>FQCN</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>FreeMarker</entry>
                            <entry>org.jboss.seam.rest.templating.freemarker.FreeMarkerProvider</entry>
                        </row>
                        <row>
                            <entry>Apache Velocity</entry>
                            <entry>org.jboss.seam.rest.templating.velocity.VelocityProvider</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect2>

    </sect1>

</chapter>